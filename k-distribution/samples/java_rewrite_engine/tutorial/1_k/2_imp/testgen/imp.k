// Copyright (c) 2014-2018 K Team. All Rights Reserved.
module IMP-SYNTAX
  syntax AExp ::= Int | Id
//                 | AExp "*" AExp [left, seqstrict]
//                 | AExp "/" AExp [left, seqstrict]
                 > AExp "+" AExp [left, seqstrict]
//                 | AExp "-" AExp [left, seqstrict]
                 | "(" AExp ")" [bracket]
  syntax BExp ::= Bool
                 | AExp "<" AExp [seqstrict]
//                 | AExp "<=" AExp [seqstrict, latex({#1}\leq{#2})]
//                 | AExp ">" AExp [seqstrict]
//                 | AExp ">=" AExp [seqstrict, latex({#1}\geq{#2})]
                 | "!" BExp [strict]
                 > BExp "&&" BExp [left, strict(1)]
                 | "(" BExp ")" [bracket]
  syntax Block ::= "{" "}"
                 | "{" Stmt "}"
//  syntax Block ::= "{" Stmt "}"
  syntax Stmt ::= Block
                 | Id "=" AExp ";" [strict(2), testgen-category(ASSIGN)]
                 | "if" "(" BExp ")"
                   Block "else" Block [strict(1), testgen-category(IF)]
                 | "while" "(" BExp ")" Block
                 > Stmt Stmt [left]
  syntax Pgm ::= "int" Ids ";" Stmt
  syntax Ids ::= List{Id,","}

  // special identifiers (for matching-logic specifications)
  syntax Id ::= Token{"n"} | Token{"x"} | Token{"y"} | Token{"$1"} [prefer]
endmodule

module IMP
  imports IMP-SYNTAX
  syntax KResult ::= Int | Bool

  configuration <T color="yellow">
                  //<k color="green"> $PGM:Pgm </k>
                  <k color="green"> $PGM:K </k>
                  <state color="red"> .Map </state>
                </T>

// AExp
  rule <k> X:Id => I ...</k> <state>... X |-> I:KItem ...</state>
//  rule I1 / I2 => I1 /Int I2 when I2 =/=Int 0
  rule [add]: I1 + I2 => I1 +Int I2
//  rule [minus]: I1 - I2 => I1 -Int I2
//  rule [multiply]: I1 * I2 => I1 -Int I2
// BExp
  rule I1 < I2 => I1 <Int I2
//  rule I1 <= I2 => I1 <=Int I2
//  rule I1 > I2 => I1 >Int I2
//  rule I1 >= I2 => I1 >=Int I2
  rule ! T => notBool T
  rule true && B => B
  rule false && _ => false
// Block
  rule {} => . [structural, testgen-category(BLOCK)]
  rule {S} => S [structural, testgen-category(BLOCK)]
// Stmt
  rule [assignment]:
       <k> X = I:Int; => . ...</k>
       <state>... X |-> (_:KItem => I) ...</state> [testgen-category(ASSIGN)]
  rule [assgn2]:
       <k> X = I:Int; => . ...</k>
       <state>... X |-> (_:KItem => I) ...</state> when X =/=K $1 [testgen-precede(assignment), testgen-category(ASSIGN)]
  rule X = Y:Id + A; => Y + A ~> X = HOLE; [heat, testgen-precede(heat('_=_;,1)), testgen-category(ASSIGN)]
  rule X = Y:Id + A; => Y + A ~> X = HOLE; [heat, testgen-precede(assgn2), testgen-category(ASSIGN)]
  /* not a code-generation pattern; but still looks useful*/
  // the following rule is problematic: unlike the above rule, there is no MapLookup
  // and, thus, X is still free. Then what?!
  // Furthermore, we don't really need to tweek semantics like this, since we will use
  // assertion heavily in the future, no need to spend time tuning behavior just for the
  // sake of accumulating effects
//  rule X = X + 17; => X + 17 ~> X = HOLE; when X =/=K $1 [heat, testgen-precede(assgn2)]


  // the following has sort annotation to avoid ambiguity with Map, MySet, etc
  rule [seq-composition]: S1:Stmt S2:Stmt => S1 ~> S2 [structural]
  // TODO: I am afraid using builtin term-equality is not the right way to go
  // because it requires both argument to be both ground!!! Extremely rigid!
  rule S1:Stmt S2:Stmt => S1 ~> S2 requires S1 =/=K {} andBool S2 =/=K {} [structural, testgen-precede(seq-composition), testgen-category(SEQ-COMP)]

  rule [if-true]: if (true) S else _ => S [testgen-category(IF)]
  rule [if-false]: if (false) _ else S => S [testgen-category(IF)]
  rule [while-loop]: while (B) S => if (B) {S while (B) S} else {} [structural, testgen-category(WHILE)]

  /* A testgen preceding is always an instance of the preceded(i.e. shadowed) rule,
   * therefore the ability of the original semantics to "run" a program is never
   * compromised. The only effect of a testgen preceding rule is that it will
   * restrict the forms of the programs to be generated by shadowing the preceded
   * rule when doing unification.
   */
  rule while ($1 < 3) { S:Stmt $1 = $1 + 1; } => if ($1 < 3) {{ S $1 = $1 + 1; } while ($1 < 3) { S $1 = $1 + 1; }} else {}
    [structural, testgen-precede(while-loop), testgen-category(WHILE)]
/**
 * I would like to write the following but I couldn't
 * because '_==K_ is rigid, i.e., it is not driven by
 * unification.
 */
/*  rule while (B) S => if (B) {S while (B) S} else {}
    requires B ==K ($1 < 2) andBool S ==K { S':Stmt $1 = $1 + 1; }
    [structural, testgen-precede(while-loop)]
*/

// Pgm
  rule
    <k> int (X, Xs => Xs); _ </k>
    <state> Rho:Map (.Map => X |-> 0) </state>
      when notBool (X in keys(Rho))
  rule int .Ids; S => S [structural]

// ===TEST GENERATION SPEC===

//  rule X:Id + A2 => X ~> HOLE + A2 [heat, testgen-precede(heat('_+_,0))]
//  rule X:Id + Y:Id => X ~> HOLE + Y [heat, testgen-precede(add)]
  rule 11 + Y => Y ~> 11 + HOLE [heat, testgen-precede(heat('_+_,1))]
  rule [add2]: I1:Int + 7 => I1 +Int 7 [testgen-precede(add)]
  rule 3 + 5 => 3 +Int 5 [testgen-precede(add2)]

  rule [if-true2]: if (true) {S} else _ => {S} [testgen-precede(if-true), testgen-category(IF)]
  rule [if-false2]: if (false) _ else {S} => {S} [testgen-precede(if-false), testgen-category(IF)]
  // TODO: testgen-precede may take multiple arguments?
  rule if (B) S1 else S2 => B ~> if (HOLE) S1 else S2 [heat, testgen-precede(if-true2), testgen-category(IF)]
  rule if (B) S1 else S2 => B ~> if (HOLE) S1 else S2 [heat, testgen-precede(if-false2), testgen-category(IF)]

endmodule
